#include "Containers/String.h"
#include "Containers/StringConv.h"
#include "Misc/CoreGlobals.h"
#include "System/BaseFileSystem.h"
#include "Scripts/NativeClassExporter.h"

/*
==================
CNativeClassExporter::CNativeClassExporter
==================
*/
CNativeClassExporter::CNativeClassExporter( const std::wstring& InIncludeDir, const std::wstring& InSourceDir, const CScriptSystemStub& InStub )
	: bNativeClassesChanged( false )
	, includeDir( InIncludeDir )
	, sourceDir( InSourceDir )
	, stubs( &InStub )
{}

/*
==================
CNativeClassExporter::ExportClasses
==================
*/
void CNativeClassExporter::ExportClasses()
{
	const std::vector<TSharedPtr<CScriptClassStub>>&	classes = stubs->GetClasses();
	const std::wstring									textHeader =
		TEXT( "//\n" )
		TEXT( "// This is automatically generated by the tools.\n" )
		TEXT( "// DO NOT modify this manually! Edit the corresponding .class files instead!\n" )
		TEXT( "// Broken Singularity, All Rights Reserved.\n" )
		TEXT( "//\n\n" );

	// Read original header to compare with the new one later
	std::wstring	pathToHeader = CString::Format( TEXT( "%s" ) PATH_SEPARATOR TEXT( "EngineClasses.h" ), includeDir.c_str() );
	std::wstring	originalHeader;
	{
		CArchive*	fileArchive = g_FileSystem->CreateFileReader( pathToHeader );
		if ( fileArchive )
		{
			std::string		buffer;
			buffer.resize( fileArchive->GetSize() );
			fileArchive->Serialize( buffer.data(), buffer.size() );
			originalHeader = ANSI_TO_TCHAR( buffer.c_str() );
			delete fileArchive;
		}
	}

	// Generate a new header file for native classes
	std::wstring	newHeader = textHeader;
	for ( uint32 classIdx = 0, numClasses = classes.size(); classIdx < numClasses; ++classIdx )
	{
		// We export only native classes
		const TSharedPtr<CScriptClassStub>		theClass = classes[classIdx];
		if ( !theClass->IsNative() )
		{
			continue;
		}

		// Export native class
		ExportClass( newHeader, theClass );
		newHeader += TEXT( "\n" );
	}

	// If header file is changed we save the new one
	if ( originalHeader != newHeader )
	{
		CArchive*	fileArchive = g_FileSystem->CreateFileWriter( pathToHeader, AW_NoFail );
		fileArchive->Serialize( TCHAR_TO_ANSI( newHeader.c_str() ), newHeader.size() );
		delete fileArchive;
		bNativeClassesChanged = true;
	}
}

/*
==================
CNativeClassExporter::ExportClass
==================
*/
void CNativeClassExporter::ExportClass( std::wstring& InOutFileData, const TSharedPtr<CScriptClassStub>& InClassStub )
{
	// We export only native classes
	if ( !InClassStub->IsNative() )
	{
		return;
	}

	const std::wstring&										className		= InClassStub->GetName();
	const std::wstring&										superClassName	= InClassStub->GetSuperClassName();
	const std::vector<TSharedPtr<CScriptFunctionStub>>&		functions		= InClassStub->GetFunctions();
	
	// Export function for register native functions
	std::wstring											declareRegisterNatives = TEXT( "" );
	if ( !functions.empty() )
	{
		declareRegisterNatives += TEXT( "\tDECLARE_REGISTER_NATIVES()\n" );
		declareRegisterNatives += TEXT( "\t{\n" );
		declareRegisterNatives += CString::Format( TEXT( "\t\tstatic ReflectionFunctionDesc s_%sNativeFunctions[] =\n" ), className.c_str() );
		declareRegisterNatives += TEXT( "\t\t{\n" );
		for ( uint32 funcIdx = 0, numFunctions = functions.size(); funcIdx < numFunctions; ++funcIdx )
		{
			TSharedPtr<CScriptFunctionStub>		function = functions[funcIdx];
			if ( function->IsNative() )
			{
				std::wstring	functionName = function->GetName();
				declareRegisterNatives += CString::Format( TEXT( "\t\t\tSCRIPT_MAP_FUNC( %s, scr%s )\n" ), className.c_str(), functionName.c_str() );
			}
		}
		declareRegisterNatives += TEXT( "\t\t\t{ nullptr, nullptr }\n" );
		declareRegisterNatives += TEXT( "\t\t};\n" );
		declareRegisterNatives += CString::Format( TEXT( "\t\tCReflectionEnvironment::Get().AddNativeFunctions( CName( TEXT( \"%s\" ) ), s_%sNativeFunctions );\n" ), className.c_str(), className.c_str() );
		declareRegisterNatives += TEXT( "\t}" );
	}
	
	InOutFileData += CString::Format( TEXT( "class %s : public %s\n" )
								  TEXT( "{\n" )
								  TEXT( "\tDECLARE_CLASS( %s, %s, 0, 0 )\n" )
								  TEXT( "\tNO_DEFAULT_CONSTRUCTOR( %s )\n" )
								  TEXT( "%s\n\n" )
								  TEXT( "public:\n" ),
								  className.c_str(), superClassName.c_str(), className.c_str(), superClassName.c_str(), className.c_str(), declareRegisterNatives.c_str() );

	// Export native functions
	for ( uint32 funcIdx = 0, numFunctions = functions.size(); funcIdx < numFunctions; ++funcIdx )
	{
		TSharedPtr<CScriptFunctionStub>		function = functions[funcIdx];
		if ( function->IsNative() )
		{
			Assert( function->GetParams().empty() );	// We currently not support native functions with parameters. TODO yehor.pohuliaka - Need implement
			std::wstring		functionName = function->GetName();
			InOutFileData += CString::Format( TEXT( "\tvirtual %s %s();\n" ), function->GetReturnTypeName().c_str(), functionName.c_str() );
			InOutFileData += CString::Format( TEXT( "\tDECLARE_FUNCTION( scr%s )\n" ), functionName.c_str() );
			InOutFileData += TEXT( "\t{\n" );
			InOutFileData += CString::Format( TEXT( "\t\tthis->%s();\n" ), functionName.c_str() );
			InOutFileData += TEXT( "\t}\n" );
		}
	}

	InOutFileData += TEXT( "};\n" );
}